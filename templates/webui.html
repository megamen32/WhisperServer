<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>Whisper —Å–µ—Ä–≤–µ—Ä</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            color-scheme: dark;
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            min-height: 100vh;
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(165deg, #050505, #0a1431 50%, #071728);
            color: #f4f6fb;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .page {
            width: 100%;
            padding: 32px 20px;
            display: flex;
            justify-content: center;
        }
        .ui-card {
            width: min(780px, 100%);
            background: rgba(6, 8, 19, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 36px;
            padding: 36px;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.45);
            backdrop-filter: blur(12px);
        }
            .mic-icon {
                margin: 0 auto 24px;
                width: 140px;
                height: 140px;
                border-radius: 50%;
                border: 4px solid rgba(255, 255, 255, 0.4);
                background: radial-gradient(circle at 30% 15%, rgba(125, 210, 255, 0.35), transparent 60%),
                    radial-gradient(circle at 70% 35%, rgba(120, 96, 255, 0.4), transparent 55%),
                    rgba(20, 28, 48, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 64px;
                color: #8ae1ff;
                box-shadow: 0 12px 25px rgba(0, 0, 0, 0.45);
                cursor: pointer;
                transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
            }
            .mic-icon:hover {
                transform: translateY(-2px);
            }
            .mic-icon.recording {
                border-color: #ff9f9f;
                box-shadow: 0 0 30px rgba(255, 110, 110, 0.6), 0 12px 25px rgba(0, 0, 0, 0.4);
            }
            .mic-label {
                text-align: center;
                color: rgba(255, 255, 255, 0.7);
                font-size: 0.95rem;
                margin-top: -12px;
                margin-bottom: 20px;
            }
            .drop-zone {
            border: 2px dashed rgba(252, 252, 252, 0.35);
            border-radius: 20px;
            padding: 32px;
            text-align: center;
            font-size: 1rem;
            line-height: 1.5;
            cursor: pointer;
            transition: border-color 0.2s ease, background 0.2s ease;
            background: rgba(255, 255, 255, 0.02);
        }
        .drop-zone.active {
            border-color: #72d6ff;
            background: rgba(114, 214, 255, 0.05);
        }
        .drop-zone.working {
            border-color: #36d6b8;
        }
        .drop-zone .button-link {
            color: #84d2ff;
            text-decoration: underline;
            cursor: pointer;
        }
        #file-input {
            display: none;
        }
        .controls {
            margin-top: 22px;
            display: flex;
            flex-wrap: wrap;
            gap: 14px;
            align-items: flex-end;
        }
        .control {
            flex: 1;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .control span {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }
        select,
        input[type='text'] {
            width: 100%;
            padding: 10px 14px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.04);
            color: #f4f6fb;
            font-size: 1rem;
            outline: none;
        }
        select:focus,
        input[type='text']:focus {
            border-color: #89e5ff;
            background: rgba(255, 255, 255, 0.08);
        }
        #toggle-times {
            border: none;
            background: linear-gradient(135deg, #46b5ff, #6b58ff);
            color: white;
            padding: 11px 22px;
            border-radius: 999px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(34, 92, 255, 0.35);
            transition: transform 0.2s ease;
        }
        #toggle-times:active {
            transform: translateY(2px);
        }
        .progress-track {
            margin-top: 24px;
            width: 100%;
            height: 14px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.07);
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            width: 0%;
            border-radius: 999px;
            background: linear-gradient(90deg, #7df2ff, #5ba7ff);
            transition: width 0.4s ease;
        }
        .progress-meta {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #9bbdff;
        }
        .status-bar {
            margin-top: 12px;
            text-align: center;
            font-size: 0.95rem;
            color: #b2d2ff;
        }
        .output {
            margin-top: 24px;
            max-height: 320px;
            overflow-y: auto;
            border-radius: 24px;
            padding: 18px;
            background: rgba(7, 10, 25, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        .transcript-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .segment {
            display: flex;
            gap: 12px;
            align-items: baseline;
            font-size: 1rem;
            line-height: 1.4;
            word-break: break-word;
        }
        .segment-text {
            flex: 1;
        }
        .timecode {
            font-size: 0.85rem;
            color: #7bedff;
            min-width: 90px;
            display: none;
        }
        .transcript-container.show-times .timecode {
            display: inline-block;
        }
        .final-output {
            margin-top: 16px;
            font-weight: 600;
            color: #c5ffe4;
        }
        .error-output {
            margin-top: 10px;
            color: #ff9ea1;
            min-height: 18px;
        }
        @media (max-width: 640px) {
            .ui-card {
                padding: 28px 20px;
            }
            .controls {
                flex-direction: column;
            }
            .progress-meta {
                flex-direction: column;
                gap: 6px;
            }
        }
    </style>
</head>
<body>
    <div class="page">
        <div class="ui-card">
            <div class="mic-icon" aria-hidden="true">üéôÔ∏è</div>
            <div class="mic-label" id="mic-label">–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –∑–∞–ø–∏—Å–∞—Ç—å</div>
            <div class="drop-zone" id="drop-zone">
                <p>
                    <strong>–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–∞–π–ª —Å—é–¥–∞</strong><br>
                    –∏–ª–∏ <span class="button-link" id="select-file-button">–Ω–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª</span>
                </p>
                <input type="file" id="file-input" accept="audio/*" />
            </div>
            <div class="controls">
                <label class="control">
                    <span>–ú–æ–¥–µ–ª—å (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è)</span>
                    <select id="model-select"></select>
                </label>
                <label class="control" hidden=true>
                    <span>API-–∫–ª—é—á</span>
                    <input type="text" id="api-key-input" placeholder="–£–∫–∞–∂–∏—Ç–µ –∫–ª—é—á –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π" />
                </label>
                <button type="button" id="toggle-times">–ü–æ–∫–∞–∑–∞—Ç—å —Ç–∞–π–º–∫–æ–¥—ã</button>
            </div>
            <div class="progress-track">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div class="progress-meta">
                <span id="speed-label">–°–∫–æ—Ä–æ—Å—Ç—å: ‚Äî</span>
                <span id="estimate-label">–û–∂–∏–¥–∞–Ω–∏–µ: ‚Äî</span>
            </div>
            <div class="status-bar" id="status-bar">–ì–æ—Ç–æ–≤–æ</div>
            <div class="output">
                <div id="transcript" class="transcript-container"></div>
                <div id="final-output" class="final-output"></div>
                <div id="error-output" class="error-output" aria-live="assertive"></div>
            </div>
        </div>
    <script>
        const DEFAULT_MODEL = 'base';
        const DEFAULT_API_KEY = __API_KEY__;
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const modelSelect = document.getElementById('model-select');
        const transcriptContainer = document.getElementById('transcript');
        const finalOutput = document.getElementById('final-output');
        const errorOutput = document.getElementById('error-output');
        const statusBar = document.getElementById('status-bar');
        const progressBar = document.getElementById('progress-bar');
        const speedLabel = document.getElementById('speed-label');
        const estimateLabel = document.getElementById('estimate-label');
        const toggleTimes = document.getElementById('toggle-times');
        const micIcon = document.querySelector('.mic-icon');
        const micLabel = document.getElementById('mic-label');

        let isProcessing = false;
        let showTimecodes = false;
        let startTime = 0;
        let segmentsProcessed = 0;
        let statusInterval = null;
        let estimatedWait = 0;
        let mediaRecorder = null;
        let mediaStream = null;
        let recordedChunks = [];

        const recordingSupported = typeof MediaRecorder !== 'undefined';

        document.getElementById('api-key-input').value = DEFAULT_API_KEY;

        function setStatus(message) {
            statusBar.textContent = message;
        }

        function updateRecordingUI(active) {
            micIcon.classList.toggle('recording', active);
            micLabel.textContent = active ? '–ò–¥–µ—Ç –∑–∞–ø–∏—Å—å‚Ä¶ –Ω–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å' : '–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –∑–∞–ø–∏—Å–∞—Ç—å';
        }

        function cleanupRecordingStream() {
            if (mediaStream) {
                mediaStream.getTracks().forEach((track) => track.stop());
                mediaStream = null;
            }
            mediaRecorder = null;
        }

        async function startRecording() {
            if (isProcessing) {
                errorOutput.textContent = '–ü–æ–¥–æ–∂–¥–∏—Ç–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏';
                return;
            }
            if (!recordingSupported) {
                errorOutput.textContent = '–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∑–∞–ø–∏—Å—å —Å –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞';
                return;
            }
            try {
                recordedChunks = [];
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const preferredMime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                    ? 'audio/webm;codecs=opus'
                    : 'audio/webm';
                mediaRecorder = new MediaRecorder(mediaStream, { mimeType: preferredMime });
                mediaRecorder.addEventListener('dataavailable', (event) => {
                    if (event.data && event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                });
                mediaRecorder.addEventListener('stop', () => {
                    updateRecordingUI(false);
                    cleanupRecordingStream();
                    if (!recordedChunks.length) {
                        setStatus('–ó–∞–ø–∏—Å—å –æ—Ç–º–µ–Ω–µ–Ω–∞');
                        return;
                    }
                    const blob = new Blob(recordedChunks, { type: preferredMime });
                    const file = new File([blob], `recording-${Date.now()}.webm`, { type: blob.type });
                    transcribeFile(file);
                });
                mediaRecorder.addEventListener('error', (event) => {
                    errorOutput.textContent = event.error?.message || '–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏';
                    updateRecordingUI(false);
                    cleanupRecordingStream();
                });
                mediaRecorder.start();
                setStatus('–ò–¥–µ—Ç –∑–∞–ø–∏—Å—å...');
                updateRecordingUI(true);
            } catch (error) {
                errorOutput.textContent = error.message;
                updateRecordingUI(false);
                cleanupRecordingStream();
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            } else {
                updateRecordingUI(false);
                cleanupRecordingStream();
            }
        }

        function formatTime(value = 0) {
            const minutes = Math.floor(value / 60);
            const seconds = (value % 60).toFixed(2).padStart(5, '0');
            return `${minutes}:${seconds}`;
        }

        function updateProgress(final = false) {
            if (!startTime) {
                progressBar.style.width = final ? '100%' : '0%';
                return;
            }
            const elapsed = Math.max(0.1, (Date.now() - startTime) / 1000);
            const speed = segmentsProcessed / elapsed;
            speedLabel.textContent = `–°–∫–æ—Ä–æ—Å—Ç—å: ${speed.toFixed(2)} —Å–µ–≥/—Å`;
            const waitLeft = final ? 0 : Math.max(0, estimatedWait - elapsed);
            estimateLabel.textContent = final ? '–û–∂–∏–¥–∞–Ω–∏–µ: –∑–∞–≤–µ—Ä—à–µ–Ω–æ' : `–û–∂–∏–¥–∞–Ω–∏–µ: ~${waitLeft.toFixed(1)} —Å`;
            const ratio = final ? 1 : Math.min(1, elapsed / (elapsed + Math.max(waitLeft, 1)));
            progressBar.style.width = `${Math.floor(ratio * 100)}%`;
        }

        async function refreshStatus() {
            try {
                const response = await fetch('/status');
                if (!response.ok) {
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å');
                }
                const payload = await response.json();
                const queueSize = Number(payload.queue_size || 0);
                estimatedWait = queueSize * 3 + 1;
                setStatus(queueSize ? `–í –æ—á–µ—Ä–µ–¥–∏: ${queueSize}` : '–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞...');
                updateProgress();
            } catch (error) {
                setStatus('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –æ—á–µ—Ä–µ–¥–∏');
            }
        }

        function appendSegment(segment) {
            if (!segment) {
                return;
            }
            segmentsProcessed += 1;
            const wrapper = document.createElement('div');
            wrapper.className = 'segment';
            const timestamp = document.createElement('span');
            timestamp.className = 'timecode';
            timestamp.textContent = `${formatTime(segment.start)} ‚Üí ${formatTime(segment.end)}`;
            const text = document.createElement('div');
            text.className = 'segment-text';
            text.textContent = segment.text;
            wrapper.appendChild(timestamp);
            wrapper.appendChild(text);
            transcriptContainer.appendChild(wrapper);
            transcriptContainer.scrollTop = transcriptContainer.scrollHeight;
            updateProgress();
        }

        function cleanupProcessing({ finalMessage, success = true } = {}) {
            if (statusInterval) {
                clearInterval(statusInterval);
                statusInterval = null;
            }
            dropZone.classList.remove('working');
            if (finalMessage) {
                setStatus(finalMessage);
            }
            isProcessing = false;
            if (success) {
                updateProgress(true);
            } else {
                progressBar.style.width = '0%';
            }
        }

        async function loadModels() {
            try {
                const response = await fetch('/models');
                if (!response.ok) {
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π');
                }
                const models = await response.json();
                if (Array.isArray(models) && models.length) {
                    modelSelect.innerHTML = models
                        .map((model) => `<option value="${model}">${model}</option>`)
                        .join('');
                    if (!models.includes(DEFAULT_MODEL)) {
                        modelSelect.prepend(new Option(DEFAULT_MODEL, DEFAULT_MODEL));
                    }
                    modelSelect.value = DEFAULT_MODEL;
                }
            } catch (error) {
                setStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–µ–π');
            }
        }

        async function transcribeFile(file) {
            if (!file || isProcessing) {
                if (isProcessing) {
                    errorOutput.textContent = '–ü–æ–¥–æ–∂–¥–∏—Ç–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏';
                }
                return;
            }
            isProcessing = true;
            segmentsProcessed = 0;
            startTime = Date.now();
            estimatedWait = 0;
            transcriptContainer.innerHTML = '';
            finalOutput.textContent = '';
            errorOutput.textContent = '';
            progressBar.style.width = '0%';
            dropZone.classList.add('working');
            setStatus('–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä...');
            const apiKeyValue = document.getElementById('api-key-input').value.trim() || DEFAULT_API_KEY;
            const form = new FormData();
            form.append('file', file);
            const requestUrl = new URL('/transcribe', window.location.origin);
            requestUrl.searchParams.set('stream', 'true');
            requestUrl.searchParams.set('model', modelSelect.value || DEFAULT_MODEL);
            requestUrl.searchParams.set('api_key', apiKeyValue);
            refreshStatus();
            statusInterval = setInterval(refreshStatus, 1800);
            try {
                const response = await fetch(requestUrl, {
                    method: 'POST',
                    body: form,
                });
                if (!response.ok) {
                    const message = await response.text();
                    throw new Error(message || `–û—à–∏–±–∫–∞: ${response.status}`);
                }
                const reader = response.body?.getReader();
                if (!reader) {
                    throw new Error('–°–µ—Ä–≤–µ—Ä –Ω–µ –≤–µ—Ä–Ω—É–ª –ø–æ—Ç–æ–∫');
                }
                const decoder = new TextDecoder('utf-8');
                let buffer = '';
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        break;
                    }
                    buffer += decoder.decode(value, { stream: true });
                    let newlineIndex;
                    while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
                        const line = buffer.slice(0, newlineIndex).trim();
                        buffer = buffer.slice(newlineIndex + 1);
                        if (!line) {
                            continue;
                        }
                        const payload = JSON.parse(line);
                        if (payload.error) {
                            throw new Error(payload.error);
                        }
                        if (payload.segment) {
                            appendSegment(payload.segment);
                        }
                        if (payload.result && payload.result.text) {
                            finalOutput.textContent = payload.result.text;
                        }
                    }
                }
                const tail = buffer.trim();
                if (tail) {
                    const payload = JSON.parse(tail);
                    if (payload.error) {
                        throw new Error(payload.error);
                    }
                    if (payload.segment) {
                        appendSegment(payload.segment);
                    }
                    if (payload.result && payload.result.text) {
                        finalOutput.textContent = payload.result.text;
                    }
                }
                cleanupProcessing({ finalMessage: '–ì–æ—Ç–æ–≤–æ', success: true });
            } catch (error) {
                errorOutput.textContent = error.message;
                cleanupProcessing({ finalMessage: '–û—à–∏–±–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏', success: false });
            }
        }

        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragenter', (event) => {
            event.preventDefault();
            dropZone.classList.add('active');
        });
        dropZone.addEventListener('dragover', (event) => {
            event.preventDefault();
            dropZone.classList.add('active');
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('active');
        });
        dropZone.addEventListener('drop', (event) => {
            event.preventDefault();
            dropZone.classList.remove('active');
            const selectedFile = event.dataTransfer.files?.[0];
            transcribeFile(selectedFile);
        });
        fileInput.addEventListener('change', () => {
            const selectedFile = fileInput.files?.[0];
            transcribeFile(selectedFile);
        });
        micIcon.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                stopRecording();
            } else {
                startRecording();
            }
        });
        toggleTimes.addEventListener('click', () => {
            showTimecodes = !showTimecodes;
            transcriptContainer.classList.toggle('show-times', showTimecodes);
            toggleTimes.textContent = showTimecodes ? '–°–∫—Ä—ã—Ç—å —Ç–∞–π–º–∫–æ–¥—ã' : '–ü–æ–∫–∞–∑–∞—Ç—å —Ç–∞–π–º–∫–æ–¥—ã';
        });

        loadModels();
    </script>
</body>
</html>
