<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>Whisper —Å–µ—Ä–≤–µ—Ä</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            color-scheme: dark;
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            min-height: 100vh;
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(165deg, #050505, #0a1431 50%, #071728);
            color: #f4f6fb;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .page {
            width: 100%;
            padding: 32px 20px;
            display: flex;
            justify-content: center;
        }
        .ui-card {
            width: min(780px, 100%);
            background: rgba(6, 8, 19, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 36px;
            padding: 36px;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.45);
            backdrop-filter: blur(12px);
        }
            .mic-icon {
                margin: 0 auto 24px;
                width: 140px;
                height: 140px;
                border-radius: 50%;
                border: 4px solid rgba(255, 255, 255, 0.4);
                background: radial-gradient(circle at 30% 15%, rgba(125, 210, 255, 0.35), transparent 60%),
                    radial-gradient(circle at 70% 35%, rgba(120, 96, 255, 0.4), transparent 55%),
                    rgba(20, 28, 48, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 64px;
                color: #8ae1ff;
                box-shadow: 0 12px 25px rgba(0, 0, 0, 0.45);
                cursor: pointer;
                transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
            }
            .mic-icon:hover {
                transform: translateY(-2px);
            }
            .mic-icon.recording {
                border-color: #ff9f9f;
                box-shadow: 0 0 30px rgba(255, 110, 110, 0.6), 0 12px 25px rgba(0, 0, 0, 0.4);
            }
            .mic-label {
                text-align: center;
                color: rgba(255, 255, 255, 0.7);
                font-size: 0.95rem;
                margin-top: -12px;
                margin-bottom: 20px;
            }
            .drop-zone {
            border: 2px dashed rgba(252, 252, 252, 0.35);
            border-radius: 20px;
            padding: 32px;
            text-align: center;
            font-size: 1rem;
            line-height: 1.5;
            cursor: pointer;
            transition: border-color 0.2s ease, background 0.2s ease;
            background: rgba(255, 255, 255, 0.02);
        }
        .drop-zone.active {
            border-color: #72d6ff;
            background: rgba(114, 214, 255, 0.05);
        }
        .drop-zone.working {
            border-color: #36d6b8;
        }
        .drop-zone .button-link {
            color: #84d2ff;
            text-decoration: underline;
            cursor: pointer;
        }
        #file-input {
            display: none;
        }
        .controls {
            margin-top: 22px;
            display: flex;
            flex-wrap: wrap;
            gap: 14px;
            align-items: flex-end;
        }
        .control {
            flex: 1;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .control span {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }
        select,
        input[type='text'] {
            width: 100%;
            padding: 10px 14px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.04);
            color: #f4f6fb;
            font-size: 1rem;
            outline: none;
        }
        select:focus,
        input[type='text']:focus {
            border-color: #89e5ff;
            background: rgba(255, 255, 255, 0.08);
        }
        #toggle-times {
            border: none;
            background: linear-gradient(135deg, #46b5ff, #6b58ff);
            color: white;
            padding: 11px 22px;
            border-radius: 999px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(34, 92, 255, 0.35);
            transition: transform 0.2s ease;
        }
        #toggle-times:active {
            transform: translateY(2px);
        }
        .progress-track {
            margin-top: 24px;
            width: 100%;
            height: 14px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.07);
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            width: 0%;
            border-radius: 999px;
            background: linear-gradient(90deg, #7df2ff, #5ba7ff);
            transition: width 0.4s ease;
        }
        .progress-meta {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #9bbdff;
            opacity: 0;
            transition: opacity 0.15s ease;
            pointer-events: none;
            height: 0;
            overflow: hidden;
        }
        .progress-meta.visible {
            opacity: 1;
            pointer-events: auto;
            height: auto;
        }
        .upload-track {
            margin-top: 18px;
            width: 100%;
            height: 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.06);
            overflow: hidden;
            transition: opacity 0.2s ease, height 0.2s ease, margin 0.2s ease;
        }
        .upload-bar {
            height: 100%;
            width: 0%;
            border-radius: 999px;
            background: linear-gradient(90deg, #ffb86b, #ff7d8f);
            transition: width 0.2s ease;
        }
        .upload-track.hidden {
            opacity: 0;
            pointer-events: none;
            height: 0;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        .status-bar {
            margin-top: 12px;
            text-align: center;
            font-size: 0.95rem;
            color: #b2d2ff;
        }
        .output {
            margin-top: 24px;
            max-height: 320px;
            overflow-y: auto;
            border-radius: 24px;
            padding: 18px;
            background: rgba(7, 10, 25, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        .transcript-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .segment {
            display: flex;
            gap: 12px;
            align-items: baseline;
            font-size: 1rem;
            line-height: 1.4;
            word-break: break-word;
        }
        .segment-text {
            flex: 1;
        }
        .transcript-container.segments-hidden .segment-text {
            display: none;
        }
        .timecode {
            font-size: 0.85rem;
            color: #7bedff;
            min-width: 90px;
            display: none;
        }
        .transcript-container.show-times .timecode {
            display: inline-block;
        }
        .final-output-wrapper {
            position: relative;
            margin-top: 24px;
        }
        .final-output {
            font-weight: 600;
            color: #c5ffe4;
            padding-top: 8px;
        }
        .copy-result-button {
            position: absolute;
            top: -26px;
            left: 4px;
            border: none;
            border-radius: 999px;
            background: #030303;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            line-height: 1;
            transition: background 0.2s ease, transform 0.2s ease;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
        }
        .copy-result-button .copy-icon {
            font-size: 18px;
            line-height: 1;
        }
        .copy-result-button.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(-2px);
        }
        .copy-result-button:hover {
            background: #181818;
            transform: translateY(-2px);
        }
        .error-output {
            margin-top: 10px;
            color: #ff9ea1;
            min-height: 18px;
        }
        @media (max-width: 640px) {
            .ui-card {
                padding: 28px 20px;
            }
            .controls {
                flex-direction: column;
            }
            .progress-meta {
                flex-direction: column;
                gap: 6px;
            }
            .ui-card,
            .drop-zone,
            .controls,
            .transcript-container,
            .output {
                text-align: center;
            }
            .controls {
                align-items: center;
            }
            .control {
                align-items: center;
            }
            .segment {
                flex-direction: column;
                align-items: center;
            }
            .segment-text {
                text-align: center;
            }
            .transcript-container.show-times .segment {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="page">
        <div class="ui-card">
            <div class="mic-icon" aria-hidden="true">üéôÔ∏è</div>
            <div class="mic-label" id="mic-label">–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –∑–∞–ø–∏—Å–∞—Ç—å</div>
            <div class="drop-zone" id="drop-zone">
                <p>
                    <strong>–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–∞–π–ª —Å—é–¥–∞</strong><br>
                    –∏–ª–∏ <span class="button-link" id="select-file-button">–Ω–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª</span>
                </p>
                <input type="file" id="file-input" accept="audio/*" />
            </div>
            <div class="controls">
                <label class="control">
                    <span>–ú–æ–¥–µ–ª—å (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è)</span>
                    <select id="model-select"></select>
                </label>
                <label class="control" style="display: none;">
                    <span>API-–∫–ª—é—á</span>
                    <input type="text" id="api-key-input" placeholder="–£–∫–∞–∂–∏—Ç–µ –∫–ª—é—á –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π" />
                </label>
                <button type="button" id="toggle-times">–ü–æ–∫–∞–∑–∞—Ç—å —Ç–∞–π–º–∫–æ–¥—ã</button>
            </div>
            <div class="upload-track hidden">
                <div class="upload-bar" id="upload-bar"></div>
            </div>
            <div class="progress-track">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div class="progress-meta">
                <span id="speed-label">–°–∫–æ—Ä–æ—Å—Ç—å: ‚Äî</span>
                <span id="estimate-label">–û–∂–∏–¥–∞–Ω–∏–µ: ‚Äî</span>
            </div>
            <div class="status-bar" id="status-bar">–ì–æ—Ç–æ–≤–æ</div>
            <div class="output">
                <div id="transcript" class="transcript-container"></div>
                <div class="final-output-wrapper">
                    <div id="final-output" class="final-output"></div>
                    <button
                        type="button"
                        id="copy-result-button"
                        class="copy-result-button hidden"
                        title="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç"
                    >
                        <span class="copy-icon" aria-hidden="true">üìã</span>
                        <span class="copy-label">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</span>
                    </button>
                </div>
                <div id="error-output" class="error-output" aria-live="assertive"></div>
            </div>
        </div>
    <script>
        const DEFAULT_MODEL = 'large-v3';
        const DEFAULT_API_KEY = __API_KEY__;
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const modelSelect = document.getElementById('model-select');
        const transcriptContainer = document.getElementById('transcript');
        const finalOutput = document.getElementById('final-output');
        const errorOutput = document.getElementById('error-output');
        const statusBar = document.getElementById('status-bar');
        const progressBar = document.getElementById('progress-bar');
        const speedLabel = document.getElementById('speed-label');
        const estimateLabel = document.getElementById('estimate-label');
        const uploadBar = document.getElementById('upload-bar');
        const uploadTrack = document.querySelector('.upload-track');
        const toggleTimes = document.getElementById('toggle-times');
        const micIcon = document.querySelector('.mic-icon');
        const micLabel = document.getElementById('mic-label');
        const copyResultButton = document.getElementById('copy-result-button');
        const progressMeta = document.querySelector('.progress-meta');

        const UPLOAD_SPEED_PREFIX = '–°–∫–æ—Ä–æ—Å—Ç—å –∑–∞–≥—Ä—É–∑–∫–∏:';
        const UPLOAD_ESTIMATE_PREFIX = '–û—Å—Ç–∞–ª–æ—Å—å:';
        const PROCESS_SPEED_PREFIX = '–°–∫–æ—Ä–æ—Å—Ç—å:';
        const PROCESS_ESTIMATE_PREFIX = '–û–∂–∏–¥–∞–Ω–∏–µ:';

        let isProcessing = false;
        let showTimecodes = false;
        let startTime = 0;
        let segmentsProcessed = 0;
        let statusInterval = null;
        let estimatedWait = 0;
        let mediaRecorder = null;
        let mediaStream = null;
        let recordedChunks = [];
        let activeXhr = null;
        let currentFile = null;
        let pendingReprocess = false;
        let uploadStartTime = 0;
        let currentUploadTotal = 0;

        const recordingSupported = typeof MediaRecorder !== 'undefined';

        document.getElementById('api-key-input').value = DEFAULT_API_KEY;
        toggleTimes.hidden = true;

        function setStatus(message) {
            statusBar.textContent = message;
        }

        function updateRecordingUI(active) {
            micIcon.classList.toggle('recording', active);
            micLabel.textContent = active ? '–ò–¥–µ—Ç –∑–∞–ø–∏—Å—å‚Ä¶ –Ω–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å' : '–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –∑–∞–ø–∏—Å–∞—Ç—å';
        }

        function cleanupRecordingStream() {
            if (mediaStream) {
                mediaStream.getTracks().forEach((track) => track.stop());
                mediaStream = null;
            }
            mediaRecorder = null;
        }

        async function startRecording() {
            if (isProcessing) {
                errorOutput.textContent = '–ü–æ–¥–æ–∂–¥–∏—Ç–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏';
                return;
            }
            if (!recordingSupported) {
                errorOutput.textContent = '–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∑–∞–ø–∏—Å—å —Å –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞';
                return;
            }
            try {
                recordedChunks = [];
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const preferredMime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                    ? 'audio/webm;codecs=opus'
                    : 'audio/webm';
                mediaRecorder = new MediaRecorder(mediaStream, { mimeType: preferredMime });
                mediaRecorder.addEventListener('dataavailable', (event) => {
                    if (event.data && event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                });
                mediaRecorder.addEventListener('stop', () => {
                    updateRecordingUI(false);
                    cleanupRecordingStream();
                    if (!recordedChunks.length) {
                        setStatus('–ó–∞–ø–∏—Å—å –æ—Ç–º–µ–Ω–µ–Ω–∞');
                        return;
                    }
                    const blob = new Blob(recordedChunks, { type: preferredMime });
                    const file = new File([blob], `recording-${Date.now()}.webm`, { type: blob.type });
                    transcribeFile(file);
                });
                mediaRecorder.addEventListener('error', (event) => {
                    errorOutput.textContent = event.error?.message || '–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏';
                    updateRecordingUI(false);
                    cleanupRecordingStream();
                });
                mediaRecorder.start();
                setStatus('–ò–¥–µ—Ç –∑–∞–ø–∏—Å—å...');
                updateRecordingUI(true);
            } catch (error) {
                errorOutput.textContent = error.message;
                updateRecordingUI(false);
                cleanupRecordingStream();
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            } else {
                updateRecordingUI(false);
                cleanupRecordingStream();
            }
        }

        function formatTime(value = 0) {
            const minutes = Math.floor(value / 60);
            const seconds = (value % 60).toFixed(2).padStart(5, '0');
            return `${minutes}:${seconds}`;
        }

        function updateProgress(final = false) {
            if (!startTime) {
                progressBar.style.width = final ? '100%' : '0%';
                return;
            }
            const elapsed = Math.max(0.1, (Date.now() - startTime) / 1000);
            const speed = segmentsProcessed / elapsed;
            speedLabel.textContent = `–°–∫–æ—Ä–æ—Å—Ç—å: ${speed.toFixed(2)} —Å–µ–≥/—Å`;
            const waitLeft = final ? 0 : Math.max(0, estimatedWait - elapsed);
            estimateLabel.textContent = final ? '–û–∂–∏–¥–∞–Ω–∏–µ: –∑–∞–≤–µ—Ä—à–µ–Ω–æ' : `–û–∂–∏–¥–∞–Ω–∏–µ: ~${waitLeft.toFixed(1)} —Å`;
            const ratio = final ? 1 : Math.min(1, elapsed / (elapsed + Math.max(waitLeft, 1)));
            progressBar.style.width = `${Math.floor(ratio * 100)}%`;
            progressMeta?.classList.add('visible');
        }

        function formatBytes(value = 0) {
            if (!Number.isFinite(value) || value <= 0) {
                return '0 B';
            }
            const units = ['B', 'KB', 'MB', 'GB'];
            let index = 0;
            let size = value;
            while (size >= 1024 && index < units.length - 1) {
                size /= 1024;
                index += 1;
            }
            return `${size.toFixed(size >= 10 || index === 0 ? 0 : 1)} ${units[index]}`;
        }

        function updateUploadProgress(loaded = 0, total = 0, done = false) {
            const safeTotal = total > 0 ? total : Math.max(loaded, 1);
            const ratio = Math.min(1, loaded / safeTotal);
            uploadBar.style.width = `${Math.floor(ratio * 100)}%`;
            const totalBytes = total > 0 ? total : currentUploadTotal;
            const elapsedSeconds = Math.max(0.001, (Date.now() - uploadStartTime) / 1000);
            const bytesPerSecond = Math.max(0, loaded / elapsedSeconds);
            const speedText = bytesPerSecond > 0 ? `${formatBytes(bytesPerSecond)}/—Å` : '‚Äî';
            speedLabel.textContent = `${UPLOAD_SPEED_PREFIX} ${speedText}`;
            if (total > 0 && bytesPerSecond > 0 && !done) {
                const eta = Math.max(0, (total - loaded) / bytesPerSecond);
                const totalText = totalBytes ? formatBytes(totalBytes) : '‚Äî';
                const loadedText = totalBytes ? formatBytes(Math.min(loaded, totalBytes)) : formatBytes(loaded);
                estimateLabel.textContent = `${UPLOAD_ESTIMATE_PREFIX} ${eta.toFixed(1)} —Å ¬∑ ${loadedText} / ${totalText}`;
            } else if (done && total > 0) {
                const totalText = totalBytes ? formatBytes(totalBytes) : '‚Äî';
                estimateLabel.textContent = `${UPLOAD_ESTIMATE_PREFIX} 0.0 —Å ¬∑ ${totalText} / ${totalText}`;
            } else {
                const totalText = totalBytes ? formatBytes(totalBytes) : '‚Äî';
                const loadedText = formatBytes(loaded);
                estimateLabel.textContent = `${UPLOAD_ESTIMATE_PREFIX} ‚Äî ¬∑ ${loadedText} / ${totalText}`;
            }
        }

        function showUploadProgress(totalBytes = 0) {
            uploadTrack.classList.remove('hidden');
            uploadBar.style.width = '0%';
            speedLabel.textContent = `${UPLOAD_SPEED_PREFIX} ‚Äî`;
            const totalText = totalBytes ? formatBytes(totalBytes) : '‚Äî';
            estimateLabel.textContent = `${UPLOAD_ESTIMATE_PREFIX} ‚Äî ¬∑ 0 / ${totalText}`;
            uploadStartTime = Date.now();
            currentUploadTotal = totalBytes;
            progressMeta?.classList.add('visible');
        }

        function hideUploadProgress(resetMeta = true) {
            uploadBar.style.width = '0%';
            uploadTrack.classList.add('hidden');
            uploadStartTime = 0;
            if (resetMeta) {
                speedLabel.textContent = `${PROCESS_SPEED_PREFIX} ‚Äî`;
                estimateLabel.textContent = `${PROCESS_ESTIMATE_PREFIX} ‚Äî`;
            }
            progressMeta?.classList.remove('visible');
        }

        async function refreshStatus() {
            try {
                const response = await fetch('/status');
                if (!response.ok) {
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å');
                }
                const payload = await response.json();
                const queueSize = Number(payload.queue_size || 0);
                estimatedWait = queueSize * 3 + 1;
                setStatus(queueSize ? `–í –æ—á–µ—Ä–µ–¥–∏: ${queueSize}` : '–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞...');
                updateProgress();
            } catch (error) {
                setStatus('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –æ—á–µ—Ä–µ–¥–∏');
            }
        }

        function appendSegment(segment) {
            if (!segment) {
                return;
            }
            segmentsProcessed += 1;
            const wrapper = document.createElement('div');
            wrapper.className = 'segment';
            const timestamp = document.createElement('span');
            timestamp.className = 'timecode';
            timestamp.textContent = `${formatTime(segment.start)} ‚Üí ${formatTime(segment.end)}`;
            const text = document.createElement('div');
            text.className = 'segment-text';
            text.textContent = segment.text;
            wrapper.appendChild(timestamp);
            wrapper.appendChild(text);
            transcriptContainer.appendChild(wrapper);
            transcriptContainer.scrollTop = transcriptContainer.scrollHeight;
            updateProgress();
        }

        function cleanupProcessing({ finalMessage, success = true } = {}) {
            if (statusInterval) {
                clearInterval(statusInterval);
                statusInterval = null;
            }
            dropZone.classList.remove('working');
            if (activeXhr) {
                activeXhr = null;
            }
            if (finalMessage) {
                setStatus(finalMessage);
            }
            isProcessing = false;
            if (success) {
                updateProgress(true);
                toggleTimes.hidden = false;
                showTimecodes = false;
                toggleTimes.textContent = '–ü–æ–∫–∞–∑–∞—Ç—å —Ç–∞–π–º–∫–æ–¥—ã';
                transcriptContainer.classList.add('segments-hidden');
                transcriptContainer.classList.remove('show-times');
            } else {
                progressBar.style.width = '0%';
                toggleTimes.hidden = true;
            }
            if (pendingReprocess && currentFile) {
                pendingReprocess = false;
                setTimeout(() => transcribeFile(currentFile), 150);
            } else {
                pendingReprocess = false;
            }
            hideUploadProgress(false);
        }

        async function loadModels() {
            try {
                const response = await fetch('/models');
                if (!response.ok) {
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π');
                }
                const models = await response.json();
                if (Array.isArray(models) && models.length) {
                    modelSelect.innerHTML = models
                        .map((model) => `<option value="${model}">${model}</option>`)
                        .join('');
                    if (!models.includes(DEFAULT_MODEL)) {
                        modelSelect.prepend(new Option(DEFAULT_MODEL, DEFAULT_MODEL));
                    }
                    modelSelect.value = DEFAULT_MODEL;
                }
            } catch (error) {
                setStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–µ–π');
            }
        }

        async function transcribeFile(file) {
            if (!file || isProcessing) {
                if (isProcessing) {
                    errorOutput.textContent = '–ü–æ–¥–æ–∂–¥–∏—Ç–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏';
                }
                return;
            }
            currentFile = file;
            isProcessing = true;
            segmentsProcessed = 0;
            startTime = Date.now();
            estimatedWait = 0;
            transcriptContainer.innerHTML = '';
            finalOutput.textContent = '';
            hideCopyButton();
            errorOutput.textContent = '';
            progressBar.style.width = '0%';
            showUploadProgress(file.size);
            dropZone.classList.add('working');
            setStatus('–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä...');
            transcriptContainer.classList.remove('segments-hidden');
            transcriptContainer.classList.remove('show-times');
            showTimecodes = false;
            toggleTimes.hidden = true;
            const apiKeyValue = document.getElementById('api-key-input').value.trim() || DEFAULT_API_KEY;
            const form = new FormData();
            form.append('file', file);
            const requestUrl = new URL('/transcribe', window.location.origin);
            requestUrl.searchParams.set('stream', 'true');
            requestUrl.searchParams.set('model', modelSelect.value || DEFAULT_MODEL);
            requestUrl.searchParams.set('api_key', apiKeyValue);

            let buffer = '';
            let responseOffset = 0;
            let hasFailed = false;

            function fail(message) {
                if (hasFailed) {
                    return;
                }
                hasFailed = true;
                errorOutput.textContent = message;
                cleanupProcessing({ finalMessage: '–û—à–∏–±–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏', success: false });
                if (activeXhr && activeXhr.readyState !== 4) {
                    activeXhr.abort();
                }
            }

            function handlePayload(payload) {
                if (!payload) {
                    return;
                }
                if (payload.error) {
                    fail(payload.error);
                    return;
                }
                if (payload.segment) {
                    appendSegment(payload.segment);
                }
                if (payload.result && payload.result.text) {
                    finalOutput.textContent = payload.result.text;
                    showCopyButton();
                }
            }

            function drainResponseText(text, flush = false) {
                if (hasFailed) {
                    return;
                }
                const chunk = text.slice(responseOffset);
                responseOffset = text.length;
                if (chunk) {
                    buffer += chunk;
                }
                let newlineIndex;
                while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
                    const line = buffer.slice(0, newlineIndex).trim();
                    buffer = buffer.slice(newlineIndex + 1);
                    if (!line) {
                        continue;
                    }
                    try {
                        const payload = JSON.parse(line);
                        handlePayload(payload);
                    } catch (error) {
                        fail('–û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ –æ—Ç–≤–µ—Ç–∞ —Å–µ—Ä–≤–µ—Ä–∞');
                        return;
                    }
                }
                if (flush) {
                    const tail = buffer.trim();
                    if (tail) {
                        try {
                            const payload = JSON.parse(tail);
                            handlePayload(payload);
                        } catch (error) {
                            fail('–û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ –æ—Ç–≤–µ—Ç–∞ —Å–µ—Ä–≤–µ—Ä–∞');
                        }
                    }
                    buffer = '';
                }
            }

            const xhr = new XMLHttpRequest();
            activeXhr = xhr;
            xhr.open('POST', requestUrl.toString(), true);
            xhr.responseType = 'text';
            xhr.upload.addEventListener('progress', (event) => {
                if (event.lengthComputable) {
                    updateUploadProgress(event.loaded, event.total);
                } else {
                    updateUploadProgress(event.loaded, file.size);
                }
            });
            xhr.upload.addEventListener('load', () => {
                updateUploadProgress(file.size, file.size, true);
                hideUploadProgress(true);
                setStatus('–§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω. –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ...');
                refreshStatus();
                statusInterval = setInterval(refreshStatus, 1800);
            });
            xhr.addEventListener('progress', () => {
                drainResponseText(xhr.responseText);
            });
            xhr.addEventListener('error', () => {
                fail('–û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ');
            });
            xhr.addEventListener('load', () => {
                if (hasFailed) {
                    return;
                }
                if (xhr.status < 200 || xhr.status >= 300) {
                    fail(xhr.responseText || `–û—à–∏–±–∫–∞: ${xhr.status}`);
                    return;
                }
                drainResponseText(xhr.responseText, true);
                cleanupProcessing({ finalMessage: '–ì–æ—Ç–æ–≤–æ', success: true });
            });
            updateUploadProgress(0, file.size);
            xhr.send(form);
        }

        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragenter', (event) => {
            event.preventDefault();
            dropZone.classList.add('active');
        });
        dropZone.addEventListener('dragover', (event) => {
            event.preventDefault();
            dropZone.classList.add('active');
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('active');
        });
        dropZone.addEventListener('drop', (event) => {
            event.preventDefault();
            dropZone.classList.remove('active');
            const selectedFile = event.dataTransfer.files?.[0];
            transcribeFile(selectedFile);
        });
        fileInput.addEventListener('change', () => {
            const selectedFile = fileInput.files?.[0];
            transcribeFile(selectedFile);
        });
        micIcon.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                stopRecording();
            } else {
                startRecording();
            }
        });
        toggleTimes.addEventListener('click', () => {
            showTimecodes = !showTimecodes;
            transcriptContainer.classList.toggle('show-times', showTimecodes);
            transcriptContainer.classList.toggle('segments-hidden', !showTimecodes);
            toggleTimes.textContent = showTimecodes ? '–°–∫—Ä—ã—Ç—å —Ç–∞–π–º–∫–æ–¥—ã' : '–ü–æ–∫–∞–∑–∞—Ç—å —Ç–∞–π–º–∫–æ–¥—ã';
        });

        copyResultButton.addEventListener('click', async () => {
            const text = finalOutput.textContent.trim();
            if (!text) {
                setStatus('–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }
            try {
                await navigator.clipboard.writeText(text);
                setStatus('–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω');
            } catch (error) {
                const fallback = document.createElement('textarea');
                fallback.value = text;
                document.body.appendChild(fallback);
                fallback.select();
                document.execCommand('copy');
                document.body.removeChild(fallback);
                setStatus('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ (—Ä–µ–∑–µ—Ä–≤–Ω–æ)');
            }
        });

        function showCopyButton() {
            copyResultButton.classList.remove('hidden');
        }

        function hideCopyButton() {
            if (!copyResultButton.classList.contains('hidden')) {
                copyResultButton.classList.add('hidden');
            }
        }

        modelSelect.addEventListener('change', () => {
            if (!currentFile) {
                return;
            }
            if (isProcessing) {
                pendingReprocess = true;
                setStatus('–ü–æ–¥–æ–∂–¥–∏—Ç–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏ ‚Äî –Ω–æ–≤–∞—è –º–æ–¥–µ–ª—å –±—É–¥–µ—Ç –ø—Ä–∏–º–µ–Ω–µ–Ω–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏');
            } else {
                transcribeFile(currentFile);
            }
        });

        loadModels();
    </script>
</body>
</html>
